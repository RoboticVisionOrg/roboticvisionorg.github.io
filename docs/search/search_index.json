{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Installing Software Import the RV GPG Key using the following command sudo -E apt-key adv --keyserver hkp://keyserver.ubuntu.com --recv-key 5B76C9B0 Add the Robotic Vision repository to the apt sources list directory sudo sh -c 'echo \"deb [arch=$(dpkg --print-architecture)] http://roboticvision.org/packages $(lsb_release -sc) main\" > /etc/apt/sources.list.d/acrv-latest.list' Update your packages list sudo apt update Resolving Rosdep Issues rosdep provides a useful mechanism for retrieving system dependencies required to build ROS packages from source. However, the list of packages maintained by the official ROS index is rather limited. As part of developing our Robotic Vision libraries we have frequently discovered dependencies that were simply not available via rosdep. To resolve this issue we have created our own index compliment that provided by ROS. To use rosdep to install depencencies needed for building the Robotic Vision libraries from source, please run the following command: sudo sh -c 'echo \"yaml https://bitbucket.org/acrv/rv_package_list/raw/HEAD/bionic/sources.yaml\" >> /etc/ros/rosdep/sources.list.d/20-default.list' rosdep update Note: This assumes that you have previously installed ROS and have run rosdep init","title":"Installing Software"},{"location":"#installing-software","text":"Import the RV GPG Key using the following command sudo -E apt-key adv --keyserver hkp://keyserver.ubuntu.com --recv-key 5B76C9B0 Add the Robotic Vision repository to the apt sources list directory sudo sh -c 'echo \"deb [arch=$(dpkg --print-architecture)] http://roboticvision.org/packages $(lsb_release -sc) main\" > /etc/apt/sources.list.d/acrv-latest.list' Update your packages list sudo apt update","title":"Installing Software"},{"location":"#resolving-rosdep-issues","text":"rosdep provides a useful mechanism for retrieving system dependencies required to build ROS packages from source. However, the list of packages maintained by the official ROS index is rather limited. As part of developing our Robotic Vision libraries we have frequently discovered dependencies that were simply not available via rosdep. To resolve this issue we have created our own index compliment that provided by ROS. To use rosdep to install depencencies needed for building the Robotic Vision libraries from source, please run the following command: sudo sh -c 'echo \"yaml https://bitbucket.org/acrv/rv_package_list/raw/HEAD/bionic/sources.yaml\" >> /etc/ros/rosdep/sources.list.d/20-default.list' rosdep update Note: This assumes that you have previously installed ROS and have run rosdep init","title":"Resolving Rosdep Issues"},{"location":"Manipulation/manipulation_driver_README/","text":"RV Manipulation Driver (RMD) NOTE: This package defines a generic interface for using a manipulator; it is NOT intended to be run directly. To use the driver with your manipulator, you must use a package that implements the driver for your arm (e.g. \"rv_panda_driver\") Overview The RV Manipulation Driver (RMD) provides a simple unified mechanism for building high-level interface configurations for seamlessly controlling a broad range of manipulators under different actuation modes. More concretly, RMD provides a mechanism for advertising high-level topics, services and action_servers for controlling a manipulator, which when called, not only actuate the manipulator based on the provided command, but also hot-swaps in the relevant low-level controllers for that actuation mode. Additionally, RMD also provides a convenient mapping to the MoveIt planning framework, and provides controller switching when it receives MoveGoal requests from MoveIt. An example configuration of RMD can be seen below: Setup RMD configurations are specified using the YAML file format and should be loaded via rosparam into the local namespace of RMD. This configuration defines: 1) a move_group name to be used when generating goals with the MoveIt planner, and 2) a list of controllers representing of one or more controller descriptions. This format can be seen below. move_group: move_group_name controllers: - Controller Description 1 - Controller Description 1 Controller Description Each controller description is composed of the following fields: Field Name Description Example topic_name Specifies the topic name to which RMD will subscribe. \"cartesian/velocity\" topic_type The topic type of the subscriber. \"geometry_msgs/Twist\" maps (optional) The topic name that RMD will republish on to communicate with the activated low-level controller. If left unspecified, RMD will switch controllers but not republish the received message. \"/cartesian_velocity_node_controller/cartesian_velocity\" controller The low-level controller required to achieve the actuation mode described by topic_name \"cartesian_velocity_node_controller\" type Specifies whether to advertise a subscriber, service or action_server \"subscriber\" Example Configuration An example configuration for the Franka-Emika Panda can be seen below: move_group: panda_arm_hand controllers: - name: \"cartesian/velocity\" topic_type: \"geometry_msgs/Twist\" type: \"publisher\" controller: \"cartesian_velocity_node_controller\" maps: \"/cartesian_velocity_node_controller/cartesian_velocity\" - name: \"/move_group/goal\" topic_type: \"moveit_msgs/MoveGroupActionGoal\" type: \"publisher\" controller: \"position_joint_trajectory_controller\" Extending RMD RMD provides basic functionality, but it is often the case that you will need to extend on these capabilities to meet the requirements of a specific manipulator. For this purpose, RMD provides access to two core interfaces, manipulation_driver and mantipulation_moveit_commander . For an example of how these modules might be extended, see the rv_panda_driver package. The extension provided in this package provides additional functionality, such as clearing errors on the e-stop being released. Subscribed Topics /arm/cartesian/velocity ( geometry_msgs/TwistStamped ) Moves the end-effector in cartesian space w.r.t. the target frame_id (base frame if no frame_id is set). /arm/joint/velocity ( rv_msgs/JointVelocity ) Moves the joints of the manipulator at the requested velocity. Published Topics /arm/state ( rv_msgs/ManipulatorState ) Provides information on the current state of the manipulator including the pose of the end-effector w.r.t. to the base link, whether the manipulator is experiencing a cartesian contact and collision as a bit-wised error state flag. Services /arm/home ( std_srvs/Empty ) Moves the robot back to its initial ready pose. /arm/recover ( std_srvs/Empty ) Recovers from collision or limit violation error states that will put the robot into a non-operable state. /arm/stop ( std_srvs/Empty ) Stops the current motion of the current. /arm/set_ee_offset ( rv_msgs/SetPose ) Sets the offset between the end-effector and the wrist of the robot arm. /arm/get_named_poses ( rv_msgs/GetNamesList ) Gets a list of currently stored named poses (includes both moveit and driver stored named poses). /arm/set_named_pose ( rv_msgs/SetNamedPose ) Saves the current joint configuration of the panda with the provided pose name. /arm/set_cartesian_impedance ( rv_msgs/SetCartesianImpedance Adjusts the impedenace of the end-effector position in cartesian space. /arm/get_link_position ( rv_msgs/GetRelativePose ) A convenience wrapper around the ROS transform lookup service that provides the relative pose of a target frame w.r.t. a reference frame. /arm/set_cartesian_planning_enabled ( std_srvs/SetBool ) Forces the path-planner to only consider linear paths when moving moving between poses with /arm/cartesian/pose /arm/get_cartesian_planning_enabled ( rv_msgs/SimpleRequest ) Checks whether the path-planner will only consider linear paths when moving moving between poses with /arm/cartesian/pose /arm/add_named_pose_config ( rv_msgs/SetNamedPoseConfig ) Instructs the driver to load named poses stored in the indicated config file. /arm/get_named_pose_configs ( rv_msgs/GetNamedPoseConfigs ) Gets the list of config files to check for named poses. /arm/remove_named_pose_config ( rv_msgs/SetNamedPoseConfig ) Instructs the driver to remove named poses stored in the indicated config file. Action API /arm/cartesian/pose ( rv_msgs/MoveToPose.action ) Moves the end-effector to the requested goal pose w.r.t. the indicated frame id. /arm/cartesian/servo_pose ( rv_msgs/ServoToPose.action ) Servos the end-effector to the requested goal pose. /arm/cartesian/named_pose ( rv_msgs/MoveToNamedPose.action ) Moves the end-effector to a pre-defined joint configuration. /arm/cartesian/servo_pose ( rv_msgs/MoveToJointPoseAction ) Moves the joints of the robot to the indicated positions (radians). /arm/gripper ( rv_msgs/ActuateGripper.action ) Actuates the gripper based on the requested mode. The static mode will move the gripper to the requested width. The grasp mode will attempt to grasp an object of width plus/minus a tolernace factor.","title":"RV Manipulation Driver (RMD)"},{"location":"Manipulation/manipulation_driver_README/#rv-manipulation-driver-rmd","text":"NOTE: This package defines a generic interface for using a manipulator; it is NOT intended to be run directly. To use the driver with your manipulator, you must use a package that implements the driver for your arm (e.g. \"rv_panda_driver\")","title":"RV Manipulation Driver (RMD)"},{"location":"Manipulation/manipulation_driver_README/#overview","text":"The RV Manipulation Driver (RMD) provides a simple unified mechanism for building high-level interface configurations for seamlessly controlling a broad range of manipulators under different actuation modes. More concretly, RMD provides a mechanism for advertising high-level topics, services and action_servers for controlling a manipulator, which when called, not only actuate the manipulator based on the provided command, but also hot-swaps in the relevant low-level controllers for that actuation mode. Additionally, RMD also provides a convenient mapping to the MoveIt planning framework, and provides controller switching when it receives MoveGoal requests from MoveIt. An example configuration of RMD can be seen below:","title":"Overview"},{"location":"Manipulation/manipulation_driver_README/#setup","text":"RMD configurations are specified using the YAML file format and should be loaded via rosparam into the local namespace of RMD. This configuration defines: 1) a move_group name to be used when generating goals with the MoveIt planner, and 2) a list of controllers representing of one or more controller descriptions. This format can be seen below. move_group: move_group_name controllers: - Controller Description 1 - Controller Description 1","title":"Setup"},{"location":"Manipulation/manipulation_driver_README/#controller-description","text":"Each controller description is composed of the following fields: Field Name Description Example topic_name Specifies the topic name to which RMD will subscribe. \"cartesian/velocity\" topic_type The topic type of the subscriber. \"geometry_msgs/Twist\" maps (optional) The topic name that RMD will republish on to communicate with the activated low-level controller. If left unspecified, RMD will switch controllers but not republish the received message. \"/cartesian_velocity_node_controller/cartesian_velocity\" controller The low-level controller required to achieve the actuation mode described by topic_name \"cartesian_velocity_node_controller\" type Specifies whether to advertise a subscriber, service or action_server \"subscriber\"","title":"Controller Description"},{"location":"Manipulation/manipulation_driver_README/#example-configuration","text":"An example configuration for the Franka-Emika Panda can be seen below: move_group: panda_arm_hand controllers: - name: \"cartesian/velocity\" topic_type: \"geometry_msgs/Twist\" type: \"publisher\" controller: \"cartesian_velocity_node_controller\" maps: \"/cartesian_velocity_node_controller/cartesian_velocity\" - name: \"/move_group/goal\" topic_type: \"moveit_msgs/MoveGroupActionGoal\" type: \"publisher\" controller: \"position_joint_trajectory_controller\"","title":"Example Configuration"},{"location":"Manipulation/manipulation_driver_README/#extending-rmd","text":"RMD provides basic functionality, but it is often the case that you will need to extend on these capabilities to meet the requirements of a specific manipulator. For this purpose, RMD provides access to two core interfaces, manipulation_driver and mantipulation_moveit_commander . For an example of how these modules might be extended, see the rv_panda_driver package. The extension provided in this package provides additional functionality, such as clearing errors on the e-stop being released.","title":"Extending RMD"},{"location":"Manipulation/manipulation_driver_README/#subscribed-topics","text":"/arm/cartesian/velocity ( geometry_msgs/TwistStamped ) Moves the end-effector in cartesian space w.r.t. the target frame_id (base frame if no frame_id is set). /arm/joint/velocity ( rv_msgs/JointVelocity ) Moves the joints of the manipulator at the requested velocity.","title":"Subscribed Topics"},{"location":"Manipulation/manipulation_driver_README/#published-topics","text":"/arm/state ( rv_msgs/ManipulatorState ) Provides information on the current state of the manipulator including the pose of the end-effector w.r.t. to the base link, whether the manipulator is experiencing a cartesian contact and collision as a bit-wised error state flag.","title":"Published Topics"},{"location":"Manipulation/manipulation_driver_README/#services","text":"/arm/home ( std_srvs/Empty ) Moves the robot back to its initial ready pose. /arm/recover ( std_srvs/Empty ) Recovers from collision or limit violation error states that will put the robot into a non-operable state. /arm/stop ( std_srvs/Empty ) Stops the current motion of the current. /arm/set_ee_offset ( rv_msgs/SetPose ) Sets the offset between the end-effector and the wrist of the robot arm. /arm/get_named_poses ( rv_msgs/GetNamesList ) Gets a list of currently stored named poses (includes both moveit and driver stored named poses). /arm/set_named_pose ( rv_msgs/SetNamedPose ) Saves the current joint configuration of the panda with the provided pose name. /arm/set_cartesian_impedance ( rv_msgs/SetCartesianImpedance Adjusts the impedenace of the end-effector position in cartesian space. /arm/get_link_position ( rv_msgs/GetRelativePose ) A convenience wrapper around the ROS transform lookup service that provides the relative pose of a target frame w.r.t. a reference frame. /arm/set_cartesian_planning_enabled ( std_srvs/SetBool ) Forces the path-planner to only consider linear paths when moving moving between poses with /arm/cartesian/pose /arm/get_cartesian_planning_enabled ( rv_msgs/SimpleRequest ) Checks whether the path-planner will only consider linear paths when moving moving between poses with /arm/cartesian/pose /arm/add_named_pose_config ( rv_msgs/SetNamedPoseConfig ) Instructs the driver to load named poses stored in the indicated config file. /arm/get_named_pose_configs ( rv_msgs/GetNamedPoseConfigs ) Gets the list of config files to check for named poses. /arm/remove_named_pose_config ( rv_msgs/SetNamedPoseConfig ) Instructs the driver to remove named poses stored in the indicated config file.","title":"Services"},{"location":"Manipulation/manipulation_driver_README/#action-api","text":"/arm/cartesian/pose ( rv_msgs/MoveToPose.action ) Moves the end-effector to the requested goal pose w.r.t. the indicated frame id. /arm/cartesian/servo_pose ( rv_msgs/ServoToPose.action ) Servos the end-effector to the requested goal pose. /arm/cartesian/named_pose ( rv_msgs/MoveToNamedPose.action ) Moves the end-effector to a pre-defined joint configuration. /arm/cartesian/servo_pose ( rv_msgs/MoveToJointPoseAction ) Moves the joints of the robot to the indicated positions (radians). /arm/gripper ( rv_msgs/ActuateGripper.action ) Actuates the gripper based on the requested mode. The static mode will move the gripper to the requested width. The grasp mode will attempt to grasp an object of width plus/minus a tolernace factor.","title":"Action API"},{"location":"Manipulation/panda_driver_README/","text":"RV Panda Driver Overview The Panda Driver provides a convienent ROS interface to the Franka-Emika Panda robotic arm. It provides multiple control modes, and hides the complexity of changing between these modes. This package extends the RV Manipulation Driver package. Usage Launching the driver The Panda Driver is launched by: roslaunch rv_panda_driver robot_bringup.launch When starting up the Panda robot: The lights indicate the status of the robot. Blue = happy and ready to move White = happy but E-stopped Yellow = error You will need to release the joint locks through the Franka interface When operating the arm have the E-stop handy for safety at all times When the arm is E-stopped the robot can be moved freely using the wrist switch To ensure the arm is working once started you can invoke the home service. rosservice call /arm/home Moving the arm The Panda Driver provides a number of options for moving the robot arm. These include moving to fixed poses, as well as moving the arm by specifiying Cartesian velocities for the end-effector. Moving the End-Effector to an Arbitrary Pose The following code example moves the robot end-effector to an arbitrary position and orientation w.r.t. to the robot's base frame. #!/usr/bin/env python2 import rospy import actionlib from rv_msgs.msg import MoveToPoseAction, MoveToPoseGoal from geometry_msgs.msg import PoseStamped # initialise ros node rospy.init_node('move_to_points_example') # Create a ros action client to communicate with the driver client = actionlib.SimpleActionClient('/arm/cartesian/pose', MoveToPoseAction) client.wait_for_server() # Create a target pose target = PoseStamped() target.header.frame_id = 'panda_link0' # Populate with target position/orientation (READY POSE) target.pose.position.x = 0.307 target.pose.position.y = 0.000 target.pose.position.z = 0.590 target.pose.orientation.x = -1.00 target.pose.orientation.y = 0.00 target.pose.orientation.z = 0.00 target.pose.orientation.w = 0.00 # Create goal from target pose goal = MoveToPoseGoal(goal_pose=target) # Send goal and wait for it to finish client.send_goal(goal) client.wait_for_result() Servoing the End-Effector to an Arbitrary Pose The following code example servos the robot end-effector to an arbitrary position and orientation w.r.t. to the robot's base frame. #!/usr/bin/env python2 import rospy import actionlib from rv_msgs.msg import ServoToPoseAction, ServoToPoseGoal from geometry_msgs.msg import PoseStamped # initialise ros node rospy.init_node('servo_to_points_example') # Create a ros action client to communicate with the driver client = actionlib.SimpleActionClient('/arm/cartesian/servo_pose', ServoToPoseAction) client.wait_for_server() # Create a target pose target = PoseStamped() target.header.frame_id = 'panda_link0' # Populate with target position/orientation (READY POSE) target.pose.position.x = 0.307 target.pose.position.y = 0.000 target.pose.position.z = 0.590 target.pose.orientation.x = -1.00 target.pose.orientation.y = 0.00 target.pose.orientation.z = 0.00 target.pose.orientation.w = 0.00 # Create goal from target pose goal = ServoToPoseGoal(stamped_pose=target, scaling=0.5) # Send goal and wait for it to finish client.send_goal(goal) client.wait_for_result() Controlling End-Effector Cartesian Velocity The following code example moves the robot end-effector at 2cm/s in the z-axis w.r.t. robot's base-frame for a total of 5 seconds. For safety reasons the driver has an expected minimum update frequency of 100Hz. #!/usr/bin/env python2 import rospy import timeit from geometry_msgs.msg import TwistStamped # initialise ros node rospy.init_node('cartesian_motion') # Create the publisher (queue size tells ROS to only publish # the latest message) publisher = rospy.Publisher('/arm/cartesian/velocity', TwistStamped, queue_size=1) # Create an initial start time start_timer = timeit.default_timer() # Create a velocity message that will instruct the robot to # move at 2cm a second in the z-axis of the base frame. velocity = TwistStamped() velocity.twist.linear.z = 0.02 # Publish the velocity message to the Panda driver at a # frequency of 100Hz while (timeit.default_timer() - start_timer) < 5: publisher.publish(velocity) rospy.sleep(0.01) # Publish an empty TwistStamped to ensure that the arm stops moving publisher.publish(TwistStamped()) Named Joint Configurations In applications we typically define a number of task specific configurations, and it is convienent if these can be assigned names. While the MoveIt framework provide the ability to store joint configurations (called named poses ), these must be defined in the MoveIt configuration of the robot and cannot be adjusted during operation. The Panda Driver solves this issue by providing the ability to save and remember joint configurations of the Panda robot for future use, while also providing access to named poses provided by MoveIt. Saving Named Poses To save the current joint configuration of the robot with the name test_pose : rosservice call /arm/set_named_pose \"pose_name: 'test_pose' overwrite: false\" Getting Named Poses To get the set of currently stored named joint configurations (created either through the driver or MoveIt) rosservice call /arm/get_named_poses Moving to a Named Pose To move to a named named joint configuration: #!/usr/bin/env python2 import rospy import actionlib from rv_msgs.msg import MoveToNamedPoseAction, MoveToNamedPoseGoal # initialise ros node rospy.init_node('named_pose_example') # Create a ros action client to communicate with the driver client = actionlib.SimpleActionClient('/arm/cartesian/named_pose', MoveToNamedPoseAction) client.wait_for_server() # Create and send a goal to move to the named pose test_pose client.send_goal(MoveToNamedPoseGoal(pose_name='test_pose')) client.wait_for_result() Note: The goal pose can be a named pose created either by the driver or MoveIt. However, the named poses provided by the driver will take priority in the event of a naming conflict. Subscribed Topics /arm/cartesian/velocity ( geometry_msgs/TwistStamped ) Moves the end-effector in Cartesian space w.r.t. the target frame_id (base frame if no frame_id is set). /arm/joint/velocity ( rv_msgs/JointVelocity ) Moves the joints of the manipulator at the requested velocity. Published Topics /arm/state ( rv_msgs/ManipulatorState ) Provides information on the current state of the manipulator including the pose of the end-effector w.r.t. to the base link, whether the manipulator is experiencing a Cartesian contact and collision as a bit-wised error state flag. Services /arm/home ( std_srvs/Empty ) Moves the robot back to its initial ready pose. /arm/recover ( std_srvs/Empty ) Recovers from collision or limit violation error states that will put the robot into a non-operable state. /arm/stop ( std_srvs/Empty ) Stops the current motion of the current. /arm/set_ee_offset ( rv_msgs/SetPose ) Sets the offset between the end-effector and the wrist of the robot arm. /arm/get_named_poses ( rv_msgs/GetNamesList ) Gets a list of currently stored named poses (includes both MoveIt and driver stored named poses). /arm/set_named_pose ( rv_msgs/SetNamedPose ) Saves the current joint configuration of the robot with the provided pose name. /arm/set_cartesian_impedance ( rv_msgs/SetCartesianImpedance Adjusts the impedenace of the end-effector position in Cartesian space. /arm/get_link_position ( rv_msgs/GetRelativePose ) A convenience wrapper around the ROS transform lookup service that provides the relative pose of a target frame w.r.t. a reference frame. /arm/set_cartesian_planning_enabled ( std_srvs/SetBool ) Forces the path-planner to only consider linear paths when moving moving between poses with /arm/cartesian/pose /arm/get_cartesian_planning_enabled ( rv_msgs/SimpleRequest ) Checks whether the path-planner will only consider linear paths when moving moving between poses with /arm/cartesian/pose /arm/add_named_pose_config ( rv_msgs/SetNamedPoseConfig ) Instructs the driver to load named poses stored in the indicated config file. /arm/get_named_pose_configs ( rv_msgs/GetNamedPoseConfigs ) Gets the list of config files to check for named poses. /arm/remove_named_pose_config ( rv_msgs/SetNamedPoseConfig ) Instructs the driver to remove named poses stored in the indicated config file. Action API /arm/cartesian/pose ( rv_msgs/MoveToPose.action ) Moves the end-effector to the requested goal pose w.r.t. the indicated frame id. /arm/cartesian/servo_pose ( rv_msgs/ServoToPose.action ) Servos the end-effector to the requested goal pose. /arm/cartesian/named_pose ( rv_msgs/MoveToNamedPose.action ) Moves the end-effector to a pre-defined joint configuration. /arm/cartesian/servo_pose ( rv_msgs/MoveToJointPoseAction ) Moves the joints of the robot to the indicated positions (radians). /arm/gripper ( rv_msgs/ActuateGripper.action ) Actuates the gripper based on the requested mode. The static mode will move the gripper to the requested width. The grasp mode will attempt to grasp an object of width plus/minus a tolernace factor.","title":"RV Panda Driver"},{"location":"Manipulation/panda_driver_README/#rv-panda-driver","text":"","title":"RV Panda Driver"},{"location":"Manipulation/panda_driver_README/#overview","text":"The Panda Driver provides a convienent ROS interface to the Franka-Emika Panda robotic arm. It provides multiple control modes, and hides the complexity of changing between these modes. This package extends the RV Manipulation Driver package.","title":"Overview"},{"location":"Manipulation/panda_driver_README/#usage","text":"","title":"Usage"},{"location":"Manipulation/panda_driver_README/#launching-the-driver","text":"The Panda Driver is launched by: roslaunch rv_panda_driver robot_bringup.launch When starting up the Panda robot: The lights indicate the status of the robot. Blue = happy and ready to move White = happy but E-stopped Yellow = error You will need to release the joint locks through the Franka interface When operating the arm have the E-stop handy for safety at all times When the arm is E-stopped the robot can be moved freely using the wrist switch To ensure the arm is working once started you can invoke the home service. rosservice call /arm/home","title":"Launching the driver"},{"location":"Manipulation/panda_driver_README/#moving-the-arm","text":"The Panda Driver provides a number of options for moving the robot arm. These include moving to fixed poses, as well as moving the arm by specifiying Cartesian velocities for the end-effector.","title":"Moving the arm"},{"location":"Manipulation/panda_driver_README/#moving-the-end-effector-to-an-arbitrary-pose","text":"The following code example moves the robot end-effector to an arbitrary position and orientation w.r.t. to the robot's base frame. #!/usr/bin/env python2 import rospy import actionlib from rv_msgs.msg import MoveToPoseAction, MoveToPoseGoal from geometry_msgs.msg import PoseStamped # initialise ros node rospy.init_node('move_to_points_example') # Create a ros action client to communicate with the driver client = actionlib.SimpleActionClient('/arm/cartesian/pose', MoveToPoseAction) client.wait_for_server() # Create a target pose target = PoseStamped() target.header.frame_id = 'panda_link0' # Populate with target position/orientation (READY POSE) target.pose.position.x = 0.307 target.pose.position.y = 0.000 target.pose.position.z = 0.590 target.pose.orientation.x = -1.00 target.pose.orientation.y = 0.00 target.pose.orientation.z = 0.00 target.pose.orientation.w = 0.00 # Create goal from target pose goal = MoveToPoseGoal(goal_pose=target) # Send goal and wait for it to finish client.send_goal(goal) client.wait_for_result()","title":"Moving the End-Effector to an Arbitrary Pose"},{"location":"Manipulation/panda_driver_README/#servoing-the-end-effector-to-an-arbitrary-pose","text":"The following code example servos the robot end-effector to an arbitrary position and orientation w.r.t. to the robot's base frame. #!/usr/bin/env python2 import rospy import actionlib from rv_msgs.msg import ServoToPoseAction, ServoToPoseGoal from geometry_msgs.msg import PoseStamped # initialise ros node rospy.init_node('servo_to_points_example') # Create a ros action client to communicate with the driver client = actionlib.SimpleActionClient('/arm/cartesian/servo_pose', ServoToPoseAction) client.wait_for_server() # Create a target pose target = PoseStamped() target.header.frame_id = 'panda_link0' # Populate with target position/orientation (READY POSE) target.pose.position.x = 0.307 target.pose.position.y = 0.000 target.pose.position.z = 0.590 target.pose.orientation.x = -1.00 target.pose.orientation.y = 0.00 target.pose.orientation.z = 0.00 target.pose.orientation.w = 0.00 # Create goal from target pose goal = ServoToPoseGoal(stamped_pose=target, scaling=0.5) # Send goal and wait for it to finish client.send_goal(goal) client.wait_for_result()","title":"Servoing the End-Effector to an Arbitrary Pose"},{"location":"Manipulation/panda_driver_README/#controlling-end-effector-cartesian-velocity","text":"The following code example moves the robot end-effector at 2cm/s in the z-axis w.r.t. robot's base-frame for a total of 5 seconds. For safety reasons the driver has an expected minimum update frequency of 100Hz. #!/usr/bin/env python2 import rospy import timeit from geometry_msgs.msg import TwistStamped # initialise ros node rospy.init_node('cartesian_motion') # Create the publisher (queue size tells ROS to only publish # the latest message) publisher = rospy.Publisher('/arm/cartesian/velocity', TwistStamped, queue_size=1) # Create an initial start time start_timer = timeit.default_timer() # Create a velocity message that will instruct the robot to # move at 2cm a second in the z-axis of the base frame. velocity = TwistStamped() velocity.twist.linear.z = 0.02 # Publish the velocity message to the Panda driver at a # frequency of 100Hz while (timeit.default_timer() - start_timer) < 5: publisher.publish(velocity) rospy.sleep(0.01) # Publish an empty TwistStamped to ensure that the arm stops moving publisher.publish(TwistStamped())","title":"Controlling End-Effector Cartesian Velocity"},{"location":"Manipulation/panda_driver_README/#named-joint-configurations","text":"In applications we typically define a number of task specific configurations, and it is convienent if these can be assigned names. While the MoveIt framework provide the ability to store joint configurations (called named poses ), these must be defined in the MoveIt configuration of the robot and cannot be adjusted during operation. The Panda Driver solves this issue by providing the ability to save and remember joint configurations of the Panda robot for future use, while also providing access to named poses provided by MoveIt.","title":"Named Joint Configurations"},{"location":"Manipulation/panda_driver_README/#saving-named-poses","text":"To save the current joint configuration of the robot with the name test_pose : rosservice call /arm/set_named_pose \"pose_name: 'test_pose' overwrite: false\"","title":"Saving Named Poses"},{"location":"Manipulation/panda_driver_README/#getting-named-poses","text":"To get the set of currently stored named joint configurations (created either through the driver or MoveIt) rosservice call /arm/get_named_poses","title":"Getting Named Poses"},{"location":"Manipulation/panda_driver_README/#moving-to-a-named-pose","text":"To move to a named named joint configuration: #!/usr/bin/env python2 import rospy import actionlib from rv_msgs.msg import MoveToNamedPoseAction, MoveToNamedPoseGoal # initialise ros node rospy.init_node('named_pose_example') # Create a ros action client to communicate with the driver client = actionlib.SimpleActionClient('/arm/cartesian/named_pose', MoveToNamedPoseAction) client.wait_for_server() # Create and send a goal to move to the named pose test_pose client.send_goal(MoveToNamedPoseGoal(pose_name='test_pose')) client.wait_for_result() Note: The goal pose can be a named pose created either by the driver or MoveIt. However, the named poses provided by the driver will take priority in the event of a naming conflict.","title":"Moving to a Named Pose"},{"location":"Manipulation/panda_driver_README/#subscribed-topics","text":"/arm/cartesian/velocity ( geometry_msgs/TwistStamped ) Moves the end-effector in Cartesian space w.r.t. the target frame_id (base frame if no frame_id is set). /arm/joint/velocity ( rv_msgs/JointVelocity ) Moves the joints of the manipulator at the requested velocity.","title":"Subscribed Topics"},{"location":"Manipulation/panda_driver_README/#published-topics","text":"/arm/state ( rv_msgs/ManipulatorState ) Provides information on the current state of the manipulator including the pose of the end-effector w.r.t. to the base link, whether the manipulator is experiencing a Cartesian contact and collision as a bit-wised error state flag.","title":"Published Topics"},{"location":"Manipulation/panda_driver_README/#services","text":"/arm/home ( std_srvs/Empty ) Moves the robot back to its initial ready pose. /arm/recover ( std_srvs/Empty ) Recovers from collision or limit violation error states that will put the robot into a non-operable state. /arm/stop ( std_srvs/Empty ) Stops the current motion of the current. /arm/set_ee_offset ( rv_msgs/SetPose ) Sets the offset between the end-effector and the wrist of the robot arm. /arm/get_named_poses ( rv_msgs/GetNamesList ) Gets a list of currently stored named poses (includes both MoveIt and driver stored named poses). /arm/set_named_pose ( rv_msgs/SetNamedPose ) Saves the current joint configuration of the robot with the provided pose name. /arm/set_cartesian_impedance ( rv_msgs/SetCartesianImpedance Adjusts the impedenace of the end-effector position in Cartesian space. /arm/get_link_position ( rv_msgs/GetRelativePose ) A convenience wrapper around the ROS transform lookup service that provides the relative pose of a target frame w.r.t. a reference frame. /arm/set_cartesian_planning_enabled ( std_srvs/SetBool ) Forces the path-planner to only consider linear paths when moving moving between poses with /arm/cartesian/pose /arm/get_cartesian_planning_enabled ( rv_msgs/SimpleRequest ) Checks whether the path-planner will only consider linear paths when moving moving between poses with /arm/cartesian/pose /arm/add_named_pose_config ( rv_msgs/SetNamedPoseConfig ) Instructs the driver to load named poses stored in the indicated config file. /arm/get_named_pose_configs ( rv_msgs/GetNamedPoseConfigs ) Gets the list of config files to check for named poses. /arm/remove_named_pose_config ( rv_msgs/SetNamedPoseConfig ) Instructs the driver to remove named poses stored in the indicated config file.","title":"Services"},{"location":"Manipulation/panda_driver_README/#action-api","text":"/arm/cartesian/pose ( rv_msgs/MoveToPose.action ) Moves the end-effector to the requested goal pose w.r.t. the indicated frame id. /arm/cartesian/servo_pose ( rv_msgs/ServoToPose.action ) Servos the end-effector to the requested goal pose. /arm/cartesian/named_pose ( rv_msgs/MoveToNamedPose.action ) Moves the end-effector to a pre-defined joint configuration. /arm/cartesian/servo_pose ( rv_msgs/MoveToJointPoseAction ) Moves the joints of the robot to the indicated positions (radians). /arm/gripper ( rv_msgs/ActuateGripper.action ) Actuates the gripper based on the requested mode. The static mode will move the gripper to the requested width. The grasp mode will attempt to grasp an object of width plus/minus a tolernace factor.","title":"Action API"},{"location":"Manipulation/panda_setup/","text":"Setup These setup instructions assume that you have already added the Robotic Vision repositories Requirements Ubuntu 18.04 ROS Melodic Installing ROS Follow the installation instructions provided for ROS Melodic . Note: We recommend installing either the desktop or desktop-full distribution Setting up the Real-Time Kernel To install the real-time kernel run the following command: sudo apt install linux-image-5.4.13-rt7 linux-headers-5.4.13-rt7 Add the user to the realtime group sudo addgroup realtime sudo usermod -a -G realtime $(whoami) Add the following limits to the realtime group in /etc/security/limits.conf @realtime soft rtprio 99 @realtime soft priority 99 @realtime soft memlock 102400 @realtime hard rtprio 99 @realtime hard priority 99 @realtime hard memlock 102400 Reboot your machine then run the following command to make sure that you are using the RT kernel. uname -a The output of the command should contain 5.0.21-rt16 #1 SMP PREEMPT RT Installing the RV Panda Driver Install the RV Panda Driver by running the command: sudo apt install ros-melodic-rv-panda-driver","title":"Setup"},{"location":"Manipulation/panda_setup/#setup","text":"These setup instructions assume that you have already added the Robotic Vision repositories","title":"Setup"},{"location":"Manipulation/panda_setup/#requirements","text":"Ubuntu 18.04 ROS Melodic","title":"Requirements"},{"location":"Manipulation/panda_setup/#installing-ros","text":"Follow the installation instructions provided for ROS Melodic . Note: We recommend installing either the desktop or desktop-full distribution","title":"Installing ROS"},{"location":"Manipulation/panda_setup/#setting-up-the-real-time-kernel","text":"To install the real-time kernel run the following command: sudo apt install linux-image-5.4.13-rt7 linux-headers-5.4.13-rt7 Add the user to the realtime group sudo addgroup realtime sudo usermod -a -G realtime $(whoami) Add the following limits to the realtime group in /etc/security/limits.conf @realtime soft rtprio 99 @realtime soft priority 99 @realtime soft memlock 102400 @realtime hard rtprio 99 @realtime hard priority 99 @realtime hard memlock 102400 Reboot your machine then run the following command to make sure that you are using the RT kernel. uname -a The output of the command should contain 5.0.21-rt16 #1 SMP PREEMPT RT","title":"Setting up the Real-Time Kernel"},{"location":"Manipulation/panda_setup/#installing-the-rv-panda-driver","text":"Install the RV Panda Driver by running the command: sudo apt install ros-melodic-rv-panda-driver","title":"Installing the RV Panda Driver"},{"location":"Networking/routing/","text":"Routing A common issue in robotics is handling communication across different network subnets. This is pariticularly relevant for frameworks such as ROS which are highly bound to a particular network domain. To solve this, and allow for message passing between different subnets, we can make use of IP tables and network routing. Setup The image below provides an example of a common network topology, where two machines (Machines 1 and 3) exist on seperate networks but share an intermediary machine (Machine 3) that is on both networks. To allow for communucation between Machine 1 and 3, we must first add some iptables rules to Machine 2 to allow it to forward messages between networks 1 and 2. # Allow traffic to be forwarded from eth0 to wlan0 iptables -A FORWARD -i eth0 -j ACCEPT # Allow traffic to be forwarded from wlan0 to eth0 iptables -A FORWARD -i wlan0 -j ACCEPT iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE iptables -t nat -A POSTROUTING -o wlan0 -j MASQUERADE Next, we must add a routing rule on Machine 1 sudo route add -net 192.168.2.0 netmask 255.255.255.0 gw 192.168.1.1 eth0 And on Machine 3 sudo route add -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.2.1 wlan0 Testing We should now be able to ping Machine 1 from Machine 3 ~$ ping 192.168.1.2 PING 192.168.1.2 (192.168.1.2) 56(84) bytes of data. 64 bytes from 192.168.1.2: icmp_seq=1 ttl=63 time=2.08 ms 64 bytes from 192.168.1.2: icmp_seq=2 ttl=63 time=2.20 ms 64 bytes from 192.168.1.2: icmp_seq=3 ttl=63 time=2.30 ms And Machine 3 from Machine 1 ~$ ping 192.168.2.2 PING 192.168.2.2 (192.168.2.2) 56(84) bytes of data. 64 bytes from 192.168.2.2: icmp_seq=1 ttl=63 time=3.00 ms 64 bytes from 192.168.2.2: icmp_seq=2 ttl=63 time=2.48 ms 64 bytes from 192.168.2.2: icmp_seq=3 ttl=63 time=3.04 ms","title":"Routing"},{"location":"Networking/routing/#routing","text":"A common issue in robotics is handling communication across different network subnets. This is pariticularly relevant for frameworks such as ROS which are highly bound to a particular network domain. To solve this, and allow for message passing between different subnets, we can make use of IP tables and network routing.","title":"Routing"},{"location":"Networking/routing/#setup","text":"The image below provides an example of a common network topology, where two machines (Machines 1 and 3) exist on seperate networks but share an intermediary machine (Machine 3) that is on both networks. To allow for communucation between Machine 1 and 3, we must first add some iptables rules to Machine 2 to allow it to forward messages between networks 1 and 2. # Allow traffic to be forwarded from eth0 to wlan0 iptables -A FORWARD -i eth0 -j ACCEPT # Allow traffic to be forwarded from wlan0 to eth0 iptables -A FORWARD -i wlan0 -j ACCEPT iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE iptables -t nat -A POSTROUTING -o wlan0 -j MASQUERADE Next, we must add a routing rule on Machine 1 sudo route add -net 192.168.2.0 netmask 255.255.255.0 gw 192.168.1.1 eth0 And on Machine 3 sudo route add -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.2.1 wlan0","title":"Setup"},{"location":"Networking/routing/#testing","text":"We should now be able to ping Machine 1 from Machine 3 ~$ ping 192.168.1.2 PING 192.168.1.2 (192.168.1.2) 56(84) bytes of data. 64 bytes from 192.168.1.2: icmp_seq=1 ttl=63 time=2.08 ms 64 bytes from 192.168.1.2: icmp_seq=2 ttl=63 time=2.20 ms 64 bytes from 192.168.1.2: icmp_seq=3 ttl=63 time=2.30 ms And Machine 3 from Machine 1 ~$ ping 192.168.2.2 PING 192.168.2.2 (192.168.2.2) 56(84) bytes of data. 64 bytes from 192.168.2.2: icmp_seq=1 ttl=63 time=3.00 ms 64 bytes from 192.168.2.2: icmp_seq=2 ttl=63 time=2.48 ms 64 bytes from 192.168.2.2: icmp_seq=3 ttl=63 time=3.04 ms","title":"Testing"}]}