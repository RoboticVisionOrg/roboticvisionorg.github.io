{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Installing Software Import the RV GPG Key using the following command sudo -E apt-key adv --keyserver hkp://keyserver.ubuntu.com --recv-key 5B76C9B0 Add the Robotic Vision repository to the apt sources list directory sudo sh -c 'echo \"deb [arch=$(dpkg --print-architecture)] http://roboticvision.org/packages $(lsb_release -sc) main\" > /etc/apt/sources.list.d/acrv-latest.list' Update your packages list sudo apt update Resolving Rosdep Issues rosdep provides a useful mechanism for retrieving system dependencies required to build ROS packages from source. However, the list of packages maintained by the official ROS index is rather limited. As part of developing our Robotic Vision libraries we have frequently discovered dependencies that were simply not available via rosdep. To resolve this issue we have created our own index compliment that provided by ROS. To use rosdep to install depencencies needed for building the Robotic Vision libraries from source, please run the following command: sudo sh -c 'echo \"yaml https://bitbucket.org/acrv/rv_package_list/raw/HEAD/bionic/sources.yaml\" >> /etc/ros/rosdep/sources.list.d/20-default.list' rosdep update Note: This assumes that you have previously installed ROS and have run rosdep init","title":"Home"},{"location":"#installing-software","text":"Import the RV GPG Key using the following command sudo -E apt-key adv --keyserver hkp://keyserver.ubuntu.com --recv-key 5B76C9B0 Add the Robotic Vision repository to the apt sources list directory sudo sh -c 'echo \"deb [arch=$(dpkg --print-architecture)] http://roboticvision.org/packages $(lsb_release -sc) main\" > /etc/apt/sources.list.d/acrv-latest.list' Update your packages list sudo apt update","title":"Installing Software"},{"location":"#resolving-rosdep-issues","text":"rosdep provides a useful mechanism for retrieving system dependencies required to build ROS packages from source. However, the list of packages maintained by the official ROS index is rather limited. As part of developing our Robotic Vision libraries we have frequently discovered dependencies that were simply not available via rosdep. To resolve this issue we have created our own index compliment that provided by ROS. To use rosdep to install depencencies needed for building the Robotic Vision libraries from source, please run the following command: sudo sh -c 'echo \"yaml https://bitbucket.org/acrv/rv_package_list/raw/HEAD/bionic/sources.yaml\" >> /etc/ros/rosdep/sources.list.d/20-default.list' rosdep update Note: This assumes that you have previously installed ROS and have run rosdep init","title":"Resolving Rosdep Issues"},{"location":"panda_setup/","text":"Setup These setup instructions assume that you have already added the Robotic Vision repositories Requirements Ubuntu 18.04 ROS Melodic Installing ROS Follow the installation instructions provided for ROS Melodic . Note: We recommend installing either the desktop or desktop-full distribution Setting up the Real-Time Kernel To install the real-time kernel run the following command: sudo apt install linux-image-5.4.13-rt7 linux-headers-5.4.13-rt7 Add the user to the realtime group sudo addgroup realtime sudo usermod -a -G realtime $(whoami) Add the following limits to the realtime group in /etc/security/limits.conf @realtime soft rtprio 99 @realtime soft priority 99 @realtime soft memlock 102400 @realtime hard rtprio 99 @realtime hard priority 99 @realtime hard memlock 102400 Reboot your machine then run the following command to make sure that you are using the RT kernel. uname -a The output of the command should contain 5.0.21-rt16 #1 SMP PREEMPT RT Installing the RV Panda Driver Install the RV Panda Driver by running the command: sudo apt install ros-melodic-rv-panda-driver","title":"Setup"},{"location":"panda_setup/#setup","text":"These setup instructions assume that you have already added the Robotic Vision repositories","title":"Setup"},{"location":"panda_setup/#requirements","text":"Ubuntu 18.04 ROS Melodic","title":"Requirements"},{"location":"panda_setup/#installing-ros","text":"Follow the installation instructions provided for ROS Melodic . Note: We recommend installing either the desktop or desktop-full distribution","title":"Installing ROS"},{"location":"panda_setup/#setting-up-the-real-time-kernel","text":"To install the real-time kernel run the following command: sudo apt install linux-image-5.4.13-rt7 linux-headers-5.4.13-rt7 Add the user to the realtime group sudo addgroup realtime sudo usermod -a -G realtime $(whoami) Add the following limits to the realtime group in /etc/security/limits.conf @realtime soft rtprio 99 @realtime soft priority 99 @realtime soft memlock 102400 @realtime hard rtprio 99 @realtime hard priority 99 @realtime hard memlock 102400 Reboot your machine then run the following command to make sure that you are using the RT kernel. uname -a The output of the command should contain 5.0.21-rt16 #1 SMP PREEMPT RT","title":"Setting up the Real-Time Kernel"},{"location":"panda_setup/#installing-the-rv-panda-driver","text":"Install the RV Panda Driver by running the command: sudo apt install ros-melodic-rv-panda-driver","title":"Installing the RV Panda Driver"},{"location":"rv_manipulation_driver/","text":"RV Manipulation Driver (RMD) NOTE: This package defines a generic interface for using a manipulator; it is NOT intended to be run directly. To use the driver with your manipulator, you must use a package that implements the driver for your arm (e.g. \"rv_panda_driver\") Overview The RV Manipulation Driver (RMD) provides a simple unified mechanism for building high-level interface configurations for seamlessly controlling a broad range of manipulators under different actuation modes. More concretly, RMD provides a mechanism for advertising high-level topics, services and action_servers for controlling a manipulator, which when called, not only actuate the manipulator based on the provided command, but also hot-swaps in the relevant low-level controllers for that actuation mode. Additionally, RMD also provides a convenient mapping to the MoveIt planning framework, and provides controller switching when it receives MoveGoal requests from MoveIt. An example configuration of RMD can be seen below: Setup RMD configurations are specified using the YAML file format and should be loaded via rosparam into the local namespace of RMD. This configuration defines: 1) a move_group name to be used when generating goals with the MoveIt planner, and 2) a list of controllers representing of one or more controller descriptions. This format can be seen below. move_group: move_group_name controllers: - Controller Description 1 - Controller Description 1 Controller Description Each controller description is composed of the following fields: Field Name Description Example topic_name Specifies the topic name to which RMD will subscribe. \"cartesian/velocity\" topic_type The topic type of the subscriber. \"geometry_msgs/Twist\" maps (optional) The topic name that RMD will republish on to communicate with the activated low-level controller. If left unspecified, RMD will switch controllers but not republish the received message. \"/cartesian_velocity_node_controller/cartesian_velocity\" controller The low-level controller required to achieve the actuation mode described by topic_name \"cartesian_velocity_node_controller\" type Specifies whether to advertise a subscriber, service or action_server \"subscriber\" Example Configuration An example configuration for the Franka-Emika Panda can be seen below: move_group: panda_arm_hand controllers: - name: \"cartesian/velocity\" topic_type: \"geometry_msgs/Twist\" type: \"publisher\" controller: \"cartesian_velocity_node_controller\" maps: \"/cartesian_velocity_node_controller/cartesian_velocity\" - name: \"/move_group/goal\" topic_type: \"moveit_msgs/MoveGroupActionGoal\" type: \"publisher\" controller: \"position_joint_trajectory_controller\" Extending RMD RMD provides basic functionality, but it is often the case that you will need to extend on these capabilities to meet the requirements of a specific manipulator. For this purpose, RMD provides access to two core interfaces, manipulation_driver and mantipulation_moveit_commander . For an example of how these modules might be extended, see the rv_panda_driver package. The extension provided in this package provides additional functionality, such as clearing errors on the e-stop being released. Action API Out of the box RMD provides access to a simple Pose Control and Named Pose Control API. Pose Control cartesian/pose/goal ( rv_msgs/MoveToPoseGoal ) Moves the end-effector to the requested goal pose w.r.t. the base frame. cartesian/pose/cancel ( actionlib_msgs/GoalID ) Cancels the currently executing goal. cartesian/pose/feedback ( rv_msgs/MoveToPoseGoal ) Feedback from the currently executing goal. cartesian/pose/status ( actionlib_msgs/GoalStatusArray ) Status information on goals sent to the driver. cartesian/pose/result ( rv_msgs/MoveToPoseGoal ) The result of the pose goal request. Named Pose Control cartesian/named_pose/goal ( rv_msgs/MoveToNamedPoseGoal ) Moves the end-effector to a pre-defined joint configuration. cartesian/named_pose/cancel ( actionlib_msgs/GoalID ) Cancels the currently executing goal. cartesian/named_pose/feedback ( rv_msgs/MoveToNamedPoseFeedback ) Feedback from the currently executing goal. cartesian/named_pose/status ( actionlib_msgs/GoalStatusArray ) Status information on goals sent to the driver. cartesian/named_pose/result ( rv_msgs/MoveToNamedPoseResult ) The result of the goal request.","title":"RV Manipulation Driver"},{"location":"rv_manipulation_driver/#rv-manipulation-driver-rmd","text":"NOTE: This package defines a generic interface for using a manipulator; it is NOT intended to be run directly. To use the driver with your manipulator, you must use a package that implements the driver for your arm (e.g. \"rv_panda_driver\")","title":"RV Manipulation Driver (RMD)"},{"location":"rv_manipulation_driver/#overview","text":"The RV Manipulation Driver (RMD) provides a simple unified mechanism for building high-level interface configurations for seamlessly controlling a broad range of manipulators under different actuation modes. More concretly, RMD provides a mechanism for advertising high-level topics, services and action_servers for controlling a manipulator, which when called, not only actuate the manipulator based on the provided command, but also hot-swaps in the relevant low-level controllers for that actuation mode. Additionally, RMD also provides a convenient mapping to the MoveIt planning framework, and provides controller switching when it receives MoveGoal requests from MoveIt. An example configuration of RMD can be seen below:","title":"Overview"},{"location":"rv_manipulation_driver/#setup","text":"RMD configurations are specified using the YAML file format and should be loaded via rosparam into the local namespace of RMD. This configuration defines: 1) a move_group name to be used when generating goals with the MoveIt planner, and 2) a list of controllers representing of one or more controller descriptions. This format can be seen below. move_group: move_group_name controllers: - Controller Description 1 - Controller Description 1","title":"Setup"},{"location":"rv_manipulation_driver/#controller-description","text":"Each controller description is composed of the following fields: Field Name Description Example topic_name Specifies the topic name to which RMD will subscribe. \"cartesian/velocity\" topic_type The topic type of the subscriber. \"geometry_msgs/Twist\" maps (optional) The topic name that RMD will republish on to communicate with the activated low-level controller. If left unspecified, RMD will switch controllers but not republish the received message. \"/cartesian_velocity_node_controller/cartesian_velocity\" controller The low-level controller required to achieve the actuation mode described by topic_name \"cartesian_velocity_node_controller\" type Specifies whether to advertise a subscriber, service or action_server \"subscriber\"","title":"Controller Description"},{"location":"rv_manipulation_driver/#example-configuration","text":"An example configuration for the Franka-Emika Panda can be seen below: move_group: panda_arm_hand controllers: - name: \"cartesian/velocity\" topic_type: \"geometry_msgs/Twist\" type: \"publisher\" controller: \"cartesian_velocity_node_controller\" maps: \"/cartesian_velocity_node_controller/cartesian_velocity\" - name: \"/move_group/goal\" topic_type: \"moveit_msgs/MoveGroupActionGoal\" type: \"publisher\" controller: \"position_joint_trajectory_controller\"","title":"Example Configuration"},{"location":"rv_manipulation_driver/#extending-rmd","text":"RMD provides basic functionality, but it is often the case that you will need to extend on these capabilities to meet the requirements of a specific manipulator. For this purpose, RMD provides access to two core interfaces, manipulation_driver and mantipulation_moveit_commander . For an example of how these modules might be extended, see the rv_panda_driver package. The extension provided in this package provides additional functionality, such as clearing errors on the e-stop being released.","title":"Extending RMD"},{"location":"rv_manipulation_driver/#action-api","text":"Out of the box RMD provides access to a simple Pose Control and Named Pose Control API.","title":"Action API"},{"location":"rv_manipulation_driver/#pose-control","text":"cartesian/pose/goal ( rv_msgs/MoveToPoseGoal ) Moves the end-effector to the requested goal pose w.r.t. the base frame. cartesian/pose/cancel ( actionlib_msgs/GoalID ) Cancels the currently executing goal. cartesian/pose/feedback ( rv_msgs/MoveToPoseGoal ) Feedback from the currently executing goal. cartesian/pose/status ( actionlib_msgs/GoalStatusArray ) Status information on goals sent to the driver. cartesian/pose/result ( rv_msgs/MoveToPoseGoal ) The result of the pose goal request.","title":"Pose Control"},{"location":"rv_manipulation_driver/#named-pose-control","text":"cartesian/named_pose/goal ( rv_msgs/MoveToNamedPoseGoal ) Moves the end-effector to a pre-defined joint configuration. cartesian/named_pose/cancel ( actionlib_msgs/GoalID ) Cancels the currently executing goal. cartesian/named_pose/feedback ( rv_msgs/MoveToNamedPoseFeedback ) Feedback from the currently executing goal. cartesian/named_pose/status ( actionlib_msgs/GoalStatusArray ) Status information on goals sent to the driver. cartesian/named_pose/result ( rv_msgs/MoveToNamedPoseResult ) The result of the goal request.","title":"Named Pose Control"},{"location":"rv_manipulation_driver/examples/","text":"Using the Panda Robot States Color Chart Unlocking the brakes Before the Panda can be used the motor brakes on the joints of the robot must be released. To accomplish","title":"Using the Panda"},{"location":"rv_manipulation_driver/examples/#using-the-panda","text":"","title":"Using the Panda"},{"location":"rv_manipulation_driver/examples/#robot-states","text":"","title":"Robot States"},{"location":"rv_manipulation_driver/examples/#color-chart","text":"","title":"Color Chart"},{"location":"rv_manipulation_driver/examples/#unlocking-the-brakes","text":"Before the Panda can be used the motor brakes on the joints of the robot must be released. To accomplish","title":"Unlocking the brakes"},{"location":"rv_panda_driver/","text":"QUT Panda Driver Overview The Panda Driver provides a series of components for initalising and controlling the Franka-Emika Panda robotic arm. This package provides a simplified interface for controlling the arm in in a variety of articulation modes by extending the RV Manipulation Driver package. ![System Diagram] (docs/Panda.png) Usage Launching the driver The Panda Driver can be launched by executing the following command: roslaunch rv_panda_driver robot_bringup.launch Other things to note when starting up the Panda: The lights indicate the status of the robot. Blue = happy and ready to move White = happy but estopped Yellow = error You will need to release the joint locks through the Franka interface When operating the arm have the E-stop handy for safety at all times When the arm is E-stopped it can be moved freely using the wrist switch To ensure the arm is working once started you can call the home routine. rosservice call /arm/home Moving the arm The Panda Driver provides a number of options for moving the robot arm. These include moving to fixed poses, as well as moving the arm by specifiying cartesian velocities for the end-effector. Moving the End-Effector to an Arbitrary Pose The following code example moves the end-effector of the Panda robot to an arbitrary position and orientation w.r.t. to the robots base frame. import rospy import actionlib from rv_msgs.msg import MoveToPoseAction, MoveToPoseGoal from geometry_msgs.msg import PoseStamped # initialise ros node rospy.init_node('move_to_points_example') # Create a ros action client to communicate with the driver client = actionlib.SimpleActionClient('/arm/cartesian/pose', MoveToPoseAction) client.wait_for_server() # Create a target pose target = PoseStamped() target.header.frame_id = 'panda_link0' # Populate with target position/orientation (READY POSE) target.pose.position.x = 0.307 target.pose.position.y = 0.000 target.pose.position.z = 0.590 target.pose.orientation.x = -1.00 target.pose.orientation.y = 0.00 target.pose.orientation.z = 0.00 target.pose.orientation.w = 0.00 # Create goal from target pose goal = MoveToPoseGoal(goal_pose=target) # Send goal and wait for it to finish client.send_goal(goal) client.wait_for_result() Moving the End-Effector in Cartesian Space The following code example moves the arm at 2cm a second in the z-axis of the base-frame for 5 seconds. For safety reasons the driver has an expected minimum frequency of 100Hz. import rospy import timeit from geometry_msgs.msg import TwistStamped # initialise ros node rospy.init_node('cartesian_motion') # Create the publisher (queue size tells ROS to only publish the latest message) publisher = rospy.Publisher('/arm/cartesian/velocity', TwistStamped, queue_size=1) # Create an initial start time start = timeit.default_timer() # Create a velocity message that will instruct the robot to move at 2cm a second in the z-axis of the base frame. velocity = TwistStamped() velocity.twist.linear.z = 0.02 # Publish the velocity message to the panda driver at a frequency of 100Hz while (timeit.default_timer() - start) < 5: publisher.publish(velocity) rospy.sleep(0.01) # Publish an empty TwistStamped to ensure that the arm stops moving publisher.publish(TwistStamped()) Managing Named Poses While the MoveIt framework provide the ability to store joint configurations as named poses, these must be defined in the MoveIt configuration of the robot and cannot be adjusted during operation. The panda driver solves this issue by providing the ability to save and remember joint configurations of the Panda arm for future, while also providing access to named poses provided by moveit. Saving Named Poses The following command demonstrates how to the current joint configuration of the robot with the name test_pose : rosservice call /arm/set_named_pose \"pose_name: 'test_pose' overwrite: false\" Getting Named Poses The following command demonstrates how to get the current set of stored named poses (created either through the driver or moveit) rosservice call /arm/get_named_poses Moving to a Named Pose The following code example demonstrates how to move to a named pose: import rospy import actionlib from rv_msgs.msg import MoveToNamedPoseAction, MoveToNamedPoseGoal # initialise ros node rospy.init_node('named_pose_example') # Create a ros action client to communicate with the driver client = actionlib.SimpleActionClient('/arm/cartesian/named_pose', MoveToNamedPoseAction) client.wait_for_server() # Create and send a goal to move to the named pose test_pose client.send_goal(MoveToNamedPoseGoal(pose_name='test_pose')) client.wait_for_result() Note: The goal pose can be a named pose created either by the driver or moveit. However, the named poses provided by the driver will take priority in the event of a naming conflict. Subscribed Topics /arm/cartesian/velocity ( geometry_msgs/TwistStamped ) Moves the end-effector in cartesian space w.r.t. the target frame_id (base frame if no frame_id is set). Publish Topics /arm/state ( rv_msgs/ManipulatorState ) Provides information on the current state of the manipulator including the pose of the end-effector w.r.t. to the base link, whether the manipulator is experiencing a cartesian contact and collision as a bit-wised error state flag. Services /arm/home ( std_srvs/Empty ) Moves the robot back to its initial ready pose. /arm/recover ( std_srvs/Empty ) Recovers from collision or limit violation error states that will put the robot into a non-operable state. /arm/stop ( std_srvs/Empty ) Stops the current motion of the current. /arm/get_named_poses (rv_msgs/GetNamesList](https://bitbucket.org/acrv/rv_msgs/src/master/srv/GetNamesList.srv)) Gets a list of currently stored named poses (includes both moveit and driver stored named poses). /arm/set_named_pose ( rv_msgs/SetNamedPose ) Saves the current joint configuration of the panda with the provided pose name. /arm/set_cartesian_impedance ( rv_msgs/SetCartesianImpedance Adjusts the impedenace of the end-effector position in cartesian space. /arm/get_link_position ( rv_msgs/GetRelativePose ) A convenience wrapper around the ROS transform lookup service that provides the relative pose of a target frame w.r.t. a reference frame. Action API Pose Control /arm/cartesian/pose ( rv_msgs/MoveToPose.action ) Moves the end-effector to the requested goal pose w.r.t. the base frame. Named Pose Control /arm/cartesian/named_pose ( rv_msgs/MoveToNamedPose.action ) Moves the end-effector to a pre-defined joint configuration. Gripper /arm/gripper ( rv_msgs/ActuateGripper.action ) Actuates the gripper based on the requested mode. The static mode will move the gripper to the requested width. The grasp mode will attempt to grasp an object of width plus/minus a tolernace factor.","title":"RV Panda Driver"},{"location":"rv_panda_driver/#qut-panda-driver","text":"","title":"QUT Panda Driver"},{"location":"rv_panda_driver/#overview","text":"The Panda Driver provides a series of components for initalising and controlling the Franka-Emika Panda robotic arm. This package provides a simplified interface for controlling the arm in in a variety of articulation modes by extending the RV Manipulation Driver package. ![System Diagram] (docs/Panda.png)","title":"Overview"},{"location":"rv_panda_driver/#usage","text":"","title":"Usage"},{"location":"rv_panda_driver/#launching-the-driver","text":"The Panda Driver can be launched by executing the following command: roslaunch rv_panda_driver robot_bringup.launch Other things to note when starting up the Panda: The lights indicate the status of the robot. Blue = happy and ready to move White = happy but estopped Yellow = error You will need to release the joint locks through the Franka interface When operating the arm have the E-stop handy for safety at all times When the arm is E-stopped it can be moved freely using the wrist switch To ensure the arm is working once started you can call the home routine. rosservice call /arm/home","title":"Launching the driver"},{"location":"rv_panda_driver/#moving-the-arm","text":"The Panda Driver provides a number of options for moving the robot arm. These include moving to fixed poses, as well as moving the arm by specifiying cartesian velocities for the end-effector.","title":"Moving the arm"},{"location":"rv_panda_driver/#moving-the-end-effector-to-an-arbitrary-pose","text":"The following code example moves the end-effector of the Panda robot to an arbitrary position and orientation w.r.t. to the robots base frame. import rospy import actionlib from rv_msgs.msg import MoveToPoseAction, MoveToPoseGoal from geometry_msgs.msg import PoseStamped # initialise ros node rospy.init_node('move_to_points_example') # Create a ros action client to communicate with the driver client = actionlib.SimpleActionClient('/arm/cartesian/pose', MoveToPoseAction) client.wait_for_server() # Create a target pose target = PoseStamped() target.header.frame_id = 'panda_link0' # Populate with target position/orientation (READY POSE) target.pose.position.x = 0.307 target.pose.position.y = 0.000 target.pose.position.z = 0.590 target.pose.orientation.x = -1.00 target.pose.orientation.y = 0.00 target.pose.orientation.z = 0.00 target.pose.orientation.w = 0.00 # Create goal from target pose goal = MoveToPoseGoal(goal_pose=target) # Send goal and wait for it to finish client.send_goal(goal) client.wait_for_result()","title":"Moving the End-Effector to an Arbitrary Pose"},{"location":"rv_panda_driver/#moving-the-end-effector-in-cartesian-space","text":"The following code example moves the arm at 2cm a second in the z-axis of the base-frame for 5 seconds. For safety reasons the driver has an expected minimum frequency of 100Hz. import rospy import timeit from geometry_msgs.msg import TwistStamped # initialise ros node rospy.init_node('cartesian_motion') # Create the publisher (queue size tells ROS to only publish the latest message) publisher = rospy.Publisher('/arm/cartesian/velocity', TwistStamped, queue_size=1) # Create an initial start time start = timeit.default_timer() # Create a velocity message that will instruct the robot to move at 2cm a second in the z-axis of the base frame. velocity = TwistStamped() velocity.twist.linear.z = 0.02 # Publish the velocity message to the panda driver at a frequency of 100Hz while (timeit.default_timer() - start) < 5: publisher.publish(velocity) rospy.sleep(0.01) # Publish an empty TwistStamped to ensure that the arm stops moving publisher.publish(TwistStamped())","title":"Moving the End-Effector in Cartesian Space"},{"location":"rv_panda_driver/#managing-named-poses","text":"While the MoveIt framework provide the ability to store joint configurations as named poses, these must be defined in the MoveIt configuration of the robot and cannot be adjusted during operation. The panda driver solves this issue by providing the ability to save and remember joint configurations of the Panda arm for future, while also providing access to named poses provided by moveit.","title":"Managing Named Poses"},{"location":"rv_panda_driver/#saving-named-poses","text":"The following command demonstrates how to the current joint configuration of the robot with the name test_pose : rosservice call /arm/set_named_pose \"pose_name: 'test_pose' overwrite: false\"","title":"Saving Named Poses"},{"location":"rv_panda_driver/#getting-named-poses","text":"The following command demonstrates how to get the current set of stored named poses (created either through the driver or moveit) rosservice call /arm/get_named_poses","title":"Getting Named Poses"},{"location":"rv_panda_driver/#moving-to-a-named-pose","text":"The following code example demonstrates how to move to a named pose: import rospy import actionlib from rv_msgs.msg import MoveToNamedPoseAction, MoveToNamedPoseGoal # initialise ros node rospy.init_node('named_pose_example') # Create a ros action client to communicate with the driver client = actionlib.SimpleActionClient('/arm/cartesian/named_pose', MoveToNamedPoseAction) client.wait_for_server() # Create and send a goal to move to the named pose test_pose client.send_goal(MoveToNamedPoseGoal(pose_name='test_pose')) client.wait_for_result() Note: The goal pose can be a named pose created either by the driver or moveit. However, the named poses provided by the driver will take priority in the event of a naming conflict.","title":"Moving to a Named Pose"},{"location":"rv_panda_driver/#subscribed-topics","text":"/arm/cartesian/velocity ( geometry_msgs/TwistStamped ) Moves the end-effector in cartesian space w.r.t. the target frame_id (base frame if no frame_id is set).","title":"Subscribed Topics"},{"location":"rv_panda_driver/#publish-topics","text":"/arm/state ( rv_msgs/ManipulatorState ) Provides information on the current state of the manipulator including the pose of the end-effector w.r.t. to the base link, whether the manipulator is experiencing a cartesian contact and collision as a bit-wised error state flag.","title":"Publish Topics"},{"location":"rv_panda_driver/#services","text":"/arm/home ( std_srvs/Empty ) Moves the robot back to its initial ready pose. /arm/recover ( std_srvs/Empty ) Recovers from collision or limit violation error states that will put the robot into a non-operable state. /arm/stop ( std_srvs/Empty ) Stops the current motion of the current. /arm/get_named_poses (rv_msgs/GetNamesList](https://bitbucket.org/acrv/rv_msgs/src/master/srv/GetNamesList.srv)) Gets a list of currently stored named poses (includes both moveit and driver stored named poses). /arm/set_named_pose ( rv_msgs/SetNamedPose ) Saves the current joint configuration of the panda with the provided pose name. /arm/set_cartesian_impedance ( rv_msgs/SetCartesianImpedance Adjusts the impedenace of the end-effector position in cartesian space. /arm/get_link_position ( rv_msgs/GetRelativePose ) A convenience wrapper around the ROS transform lookup service that provides the relative pose of a target frame w.r.t. a reference frame.","title":"Services"},{"location":"rv_panda_driver/#action-api","text":"","title":"Action API"},{"location":"rv_panda_driver/#pose-control","text":"/arm/cartesian/pose ( rv_msgs/MoveToPose.action ) Moves the end-effector to the requested goal pose w.r.t. the base frame.","title":"Pose Control"},{"location":"rv_panda_driver/#named-pose-control","text":"/arm/cartesian/named_pose ( rv_msgs/MoveToNamedPose.action ) Moves the end-effector to a pre-defined joint configuration.","title":"Named Pose Control"},{"location":"rv_panda_driver/#gripper","text":"/arm/gripper ( rv_msgs/ActuateGripper.action ) Actuates the gripper based on the requested mode. The static mode will move the gripper to the requested width. The grasp mode will attempt to grasp an object of width plus/minus a tolernace factor.","title":"Gripper"}]}